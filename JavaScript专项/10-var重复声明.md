### 问题来由
以下一段代码，输出的结果是什么？
```javascript
var b = 1;
function outer(){
    var b = 2;
    function inner(){
        b++;
        console.log(b);
        var b = 3;
    };
    inner();
}
outer();
```
答案是，NaN

解释是：
> 在函数inner中，形成内部作用域，内部作用域使用var声明了一个变量b，但是在未赋值之前，b的值是undefined。所以对b进行自增操作，操作的结果是NaN

### 延申出来的问题 - var重复声明变量
在不涉及到多重作用域的时候，使用 var 关键字重复声明一个变量，并不会每次都创建一个新变量，而是先判断是否有这个变量：有的话，直接取到这个变量，没有则给当前作用域增加这个变量。
```javascript
// 在全局作用域下
var a = 1;
a = 2;
var a = 3;
// a = 3，在第二次使用var声明a时，会先查询是否已经声明了变量a，如果已存在，直接对已存在的变量a进行操作
```

### 延伸出来的问题 - 左查询作用域链
在存在多重作用域嵌套时，如果在内层的作用域，对一个变量进行了操作，在进行左查询时，会从当前作用域开始，沿着作用域链，进行向上查找，一直找到最上层的作用域。
```javascript
var a = 1;
function f1(){
    a = 2;
    function f2(){
        a = 3
    };
    f2();
}
f1();
console.log(a); // 3
// f1执行时，a = 2，查询当前作用域（f1）是否有a变量，没有，则继续查找上一层作用域，在上一层作用域能查询成功，所以全局作用域中变量a的值，从1变为2
// f1内部函数，f2执行，a = 3，同样查询当前作用域f2是否有变量a，没有则继续向上查找，直到查找到全局作用域
// 最后输出全局作用域a的值，变为3
```

### 本题陷阱
对变量进行左查找时，会沿着作用域链进行查找。但是使用var声明变量时，对变量的查询仅限于当前作用域。所以在题中的 inner 函数中，创建上下文时，会声明一个b变量，然后值为undefined。
